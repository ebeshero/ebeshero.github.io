
<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xmlns="http://www.w3.org/1999/xhtml">


   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <link rel="stylesheet" type="text/css" href="explain.css" />
      <title>Explain XML</title>
   </head>



   <body>
      <!--#include virtual="top.html" -->
      <h1><span class="banner">Introduction to XML</span></h1>
      <h2>So. . . What exactly is <q>XML</q> anyway?</h2>
      <h3>XML: Structured, Informational Markup</h3>
      <p>XML is short for <strong>eXtensible Markup Language</strong>,and it’s a standard system for
         storing and accessing information used practically everywhere around the world. It’s the
         informational markup (or <q>code</q>) that makes Microsoft Office software run, and it’s
         the foundation of many online network applications around the world. For our purposes as
         researchers, it’s an excellent method for storing information, and for preparing to share
         it with the public. XML is independent of proprietary software applications—which means
         that what you <strong>write</strong> in XML is freely exchangeable between computers of
         different kinds (across platform—as in Macs and PCs). It outlasts software obsolescence,
         because it’s a standard that can be read universally. </p>
      <p>You’ve probably heard of HTML (hypertext markup language), which is the code that makes web
         pages presentable in web browsers. That’s a kind of XML, designed specifically and only for
         presentation and publication on the world-wide web: HTML is for <strong>presentation and
            display</strong>, but XML is primarily for <strong>storage of information</strong>, and
         we can call it <strong>informational markup</strong>, as opposed to <strong>presentational
            markup</strong>. We can write code to take information written in XML and
            <strong>transform</strong> it for presentation online—and you’ll gain experience with
         doing that as we proceed with our class this semester. </p>
      <p>XML is great for researchers in the Humanities and Social Sciences because it’s very
         effective at storing and cataloging information systematically. You can write XML to set up
            <strong>hierarchies</strong> (or nested structures) of information, and also to locate
         and extract that information later when you need it. So, if we were going to store a book
         in XML, we’d pay attention to the way it’s structured, maybe with chapters—and inside those
         chapters we’d have chapter titles, and paragraphs, and inside those, sentences, and then
         unit words and punctuation. If wanted to, we could systematically mark all the action verbs
         in those sentences, and all the exclamation points using XML, if this was important—and we
         could design a hierarchical system using XML to capture and hold the information we want to
         collect. (Sidenote: You might be surprised how important this kind of detailed tagging is,
         for example, in legal cases about who authored a book: <a
            href="http://blogs.wsj.com/speakeasy/2013/07/16/the-science-that-uncovered-j-k-rowlings-literary-hocus-pocus/"
            >Is J. K. Rowling the author of a crime novel under another name?</a> Can an
         individual’s writing style be identified as unique to them, based on their patterned use of
         certain kinds of words, like prepositions?) </p>
      <p>When we do research in the humanities, we’re working with documents written by human
         beings, and XML is useful for preserving them for reading and studying, and for extracting
         information from them later. We can do this close-up (through <strong>"close
            reading"</strong> by reading with our eyes, one by one. Or we can code documents
         systematically (which also involves <q>close reading</q>), in order to step BACK and view
         them from a distance: <strong>to let a computer discover patterns we couldn’t so easily see
            on our own.</strong> In Digital Humanities, this practice of working with computers to
         make them show us patterns across enormous, complicated texts or many, many texts, is
         called <strong><q>distant reading</q>.</strong> XML helps us prepare texts for this, for two
         reasons: </p>
      <ol>

         <li>XML is a formal model that represents an orderly structure—a hierarchy of information.
            To the extent that human documents are ordered in a systematic way, this can be
            represented and described using XML. </li>

         <li>Computers work very quickly on orderly hierarchies of information. So if we model the
            documents we want to study as hierarchies in XML, this makes it ideal for us to use
            computers to count related things, help us find patterns. </li>

      </ol>
      <p>We have to start by studying our documents to see how they’re structured, and identify what
         matters to us in describing a structure. This practice is called <strong>document
            analysis</strong>, and it’s basically what you’re doing when you have to make decisions
         about how to code a recipe, a voyage log, a poem, or a letter in our first XML exercises in
         this course. </p>
      <h3>XML is Nested Boxes, or a <q>Tree</q></h3>
      <p>In technical terms, we can think of every XML document as a <strong>tree</strong>,
         sprouting from a single root, which contains and identifies the whole thing. That outermost
         layer is the <strong>start-tag</strong> and <strong>end-tag</strong>, the alpha and the
         omega of an XML file. I tend to think of this as a single <strong>box</strong> that
         contains everything else, with all its branching complexity inside. </p>
      <div class="code">
         <span class="code"><strong>&lt;root&gt;</strong><br /> &lt;shopping_list&gt;<br />
            <span class="indent">&lt;food_item&gt;eggs&lt;/food_item&gt;</span><br />
            <span class="indent">&lt;food_item&gt;cheese&lt;/food_item&gt;</span><br />
            <span class="indent">&lt;cloth&gt;jeans&lt;/cloth&gt;</span><br />
            &lt;/shopping_list&gt;<br /> &lt;stores&gt;<br />
            <span class="indent">&lt;vendor&gt;Grocery Store&lt;/vendor&gt;</span><br />
            <span class="indent">&lt;vendor&gt;Clothing Store&lt;/vendor&gt;</span><br /> &lt;/stores&gt;<br />
            <strong>&lt;/root&gt;</strong></span>
         <br />
      </div>
      <p>XML marks a structure, or the hierarchy of a document, by using <strong>elements</strong>,
         such as shopping_list, and food_item. Each element consists of the following: </p>
      <ul>

         <li>a start-tag</li>

         <li>(whatever’s in between the tags)</li>

         <li>an end-tag</li>

      </ul>
      <p><img src="element.jpg" alt="break down of element structure" /></p>
      <p>A start tag is defined with angle brackets, and an end tag looks like a start tag, except
         it has a forward slash after the opening angle bracket. When we refer to
            <strong>tags</strong>, we’re talking about those start and end tags. When we talk about
         an <strong>element</strong>, we’re referring to the whole thing: start-tag, CONTENT, and
         end-tag. Make sense? </p>
      <p>Elements may also include something called <strong>attributes</strong>—an additional markup
         that gives supplementary information about an element. So, say we had ingredient names in
         French and Spanish in our shopping list, and we wanted to mark those: One option for doing
         this would be, say, like this: </p>
      <p>
         <span class="code">&lt;foreign language="French"&gt;escargot&lt;/foreign&gt;<br /><br />
            &lt;foreign language="Spanish"&gt;sofrito&lt;/foreign&gt;</span>
      </p>
      <p>See how this works: Attributes are written inside a start tag of an element (but NOT inside
         the end-tag). They consist of an <strong>attribute name</strong> and an <strong>attribute
            value</strong>. The attribute name, here, is <i>language</i>, and the attribute value is
         (you guessed it!) <q>French</q> or <q>Spanish.</q> (Attributes are sort of like adjectives,
         or descriptive modifiers!) Notice there’s a rule for HOW to write attributes: attribute
         values must be enclosed inside quotation marks—These can either be double straight
         quotation marks (") or single straight apostrophes (’). either one works, but try to use
         them consistently. Later on, when we’re writing other kinds of code that reads and extracts
         from your XML, you’ll find that you need to work with single quotes to refer to
         attribute values—more on that later. For now, as you write XML, double quotes are what we
         commonly use. Note that these are straight quotation marks (") and not the curly ones that
         you see in a word processor. </p>
      <h4>Self-closing elements</h4>
      <p>In special cases, XML elements can actually have <em>no text content at all</em>! 
         These are called <dfn>self-closing elements</dfn> and they have a special syntax so that they open and close inside a single tag. Here is an example:</p>
         <div class="code">
            <span class="code">&lt;lb n="2"/&gt;</span>
         </div>
      <p>Here is one use-case for a self-closing tag: We are using it to contain information about where a line of poetry ends, because our XML markup would not make that clear.
         The line numbering is not literally in the poem we are coding, but we want to record the information about the line ending in the appropriate place:</p>
         <pre>
            <span class="code">&lt;poem&gt;</span> 
               I think that I shall never see<span class="code">&lt;lb n="1"/&gt;</span>
               A poem lovely as a tree<span class="code">&lt;lb n="2"/&gt;</span>
            <span class="code">&lt;/poem&gt;</span>
         </pre>
      
      <p>This shows us a use of markup that does not simply wrap around text, but stores information that will be useful to us later in processing the file.
         Note that we could also have chosen to code the lines like this:</p>
      
      <pre>
            <span class="code">&lt;poem&gt;</span> 
               <span class="code">&lt;line n="1"&gt;</span>I think that I shall never see<span class="code">&lt;/line&gt;</span>
               <span class="code">&lt;line n="2"&gt;</span>A poem lovely as a tree<span class="code">&lt;/line&gt;</span>
            <span class="code">&lt;/poem&gt;</span>
         </pre>
         
      <p>Both ways of coding the lines of poetry are correct, and might be used for different reasons. 
         If we didn’t hold the information about the lines in <em>some</em> way, whether wrapping each line, or using self-closing tags at the end of the line, the computer parser would simply see an uninterrupted single line of text, with no notion of the meaningful nature of line breaks.</p> 
            
           
      <div class="badCode">&lt;poem&gt;I think that I shall never see     A poem lovely as a tree&lt;/poem&gt;</div>
  <p>Even though you have spaced this out with hard returns in your oXygen XML editor, to a computer parser, the text itself is a single 
     undifferentiated <dfn>string</dfn>, because in XML hard returns and extra spaces appear as meaningless space and are not meant to be treated as stable formatting.</p>
      <p>Usually we decide to write self-closing tags when we want to note simple pieces of information and where wrapping the text in open and close tags would actually cause a problem in nesting our elements. 
     We will be discussing cases where we might want to use self-closing elements as we proceed in the course. Often they have to do with preserving <q>well formedness</q>, which we discuss in the next section.</p>
  
      <h3><q>Well Formed</q> and <q>Well Formedness</q> in XML</h3>
      <p>XML must be <strong><q>well formed</q></strong> in order to be parsed by a computer. That means
         it must follow the syntax rules for writing XML: It must have <strong>a single root
            element</strong>, and its <strong>elements must be nested, without any overlap</strong>.
         Also, where attributes are used, these need to be signalled according to expected XML
         syntax (as above). These are necessary for the document to be XML. Well-formed XML is
         simply, correct XML. </p>
      <p>The following example is <strong>NOT well-formed XML</strong>. Can you tell why not? (There
         are multiple reasons!) </p>
      <div class="badCode">
         <p><span class="badCode"> &lt;dairy&gt;<br />
               <span class="indent">&lt;item&gt;milk&lt;/item&gt;</span><br />
               <span class="indent"> &lt;item&gt;yogurt&lt;/item&gt;</span><br />
               &lt;/dairy&gt;<br /> &lt;snacks&gt;<br />
               <span class="indent">&lt;item&gt;chips&lt;/item</span><br />
               <span class="indent">&lt;item&gt;pretzels&lt;/item&gt;</span><br /> &lt;/snacks&gt;<br />
               <br />
            </span></p>
      </div>
      <p>This is <strong>NOT well-formed XML</strong> either. Why not? </p>
      <div class="badCode">
         <p><span class="badCode"> &lt;paragraph&gt;He responded emphatically in French:
               &lt;emph&gt;&lt;foreign
               language="french"&gt;oui&lt;/emph&gt;&lt;/foreign&gt;!&lt;/paragraph&gt; <br />
            </span></p>
      </div>
      
      <h3>Special Reserved Characters in XML</h3>
      <p>Computers (as well as people) need to be able to read XML and tell tags apart from text, to
         distinguish elements from their content. So, we run into formedness problems (problems with
         well-formed XML) when we want to represent certain characters, like left and right angle
         brackets AS text. What if you want to write, as I’m doing here, about code and you need to
         represent tagging AS text? View my page source, look for the example passages and you’ll
         see that I’ve used a work-around solution. What we need to do is <strong>escape</strong>
         the special characters (or the <strong><q>reserved characters</q></strong>) that indicate to a
         computer that these are tags. There are three special characters that we need to escape,
         and we do this by replacing them in with <strong>character entities</strong> which tell the
         computer to display these characters as text only. We must always escape three
            characters.<strong> We’ll show you in class how to do this:</strong>
      </p>
      <ul>

         <li><span class="badCode"><strong>&amp;</strong></span>: must be replaced by <span
               class="code">&amp;amp;</span>
         </li>

         <li><span class="badCode"><strong>&lt;</strong></span>: must be replaced by <span
               class="code">&amp;lt;</span></li>

         <li><span class="badCode"><strong>&gt;</strong></span>: must be replaced by <span
               class="code">&amp;gt;</span></li>

      </ul>
      <h3>Validity in XML: Based on Schema Rules</h3>
      <p>XML is adaptable and flexible for organizing information, because it is up to the person
         writing it <em>how</em> they want to define their elements, and <em>what</em> they want to
         call them. When people work in XML in communities, though, they’ll work with specific
         tagging conventions in order to easily connect and communicate with each other. For several
         of our projects, we’re working with one of those community languages with XML called
            <q>TEI.</q> TEI is both a community and a language within XML with a standard set of
         rules, called a <strong>schema</strong>. If you work together with a group on an XML
         project, one thing you’ll need to do is define your project’s schema (or work within a
         pre-existing schema like the TEI’s) so that you’re all coding consistently. When a
         project’s XML is correct according to its defined schema, we say that the XML is
            <q>valid</q> and we run what’s called a <q>validity check</q> to determine this, in
         which we check the XML against the project’s schema file. You’ll be learning a little later
         how to write your own schemas for XML using a language called Relax-NG, but for now, we’d
         like you to get used to the actual writing of XML code and to learn some key concepts about
         it: well-formedness, nesting hierarchy, working around special reserved characters, and
         validity. </p>
      <h3>The XML Comment: Writing Comments on your Code</h3>
      <p>One last thing: In real life, coders write comments to themselves and each other in a special way that sets those comments apart from the code they are writing. As you write XML to share with others (whether for turning in assignments to the instructors of this course or for sharing code with team members or interested people on the web) you can document the decisions you made by writing little messages designed to be ignored by the computer parsing your document, but meant for human readers. Here is how to write a comment in XML:</p>
         <div class="code">
           
           <span class="code">&lt;!--</span>Here is an XML comment I am making right now! <span class="code">--&gt;</span>   
         </div>
         
      <p>The only rule for writing comments is that you cannot use angle brackets or double hyphens <em>inside</em> the comment because the computer parser will not be able to tell where your comment starts and ends. It is excellent practice in coding to write messages in comments to remind yourself of a decision or alert someone you are working with about a question or a problem, and we strongly encourage such documentation on every piece of code you write.</p>
      
   </body>




</html>
